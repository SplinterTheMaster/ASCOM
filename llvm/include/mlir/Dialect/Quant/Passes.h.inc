/* Autogenerated by mlir-tblgen; don't manually edit */
#ifdef GEN_PASS_CLASSES

//===----------------------------------------------------------------------===//
// QuantConvertConst
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class QuantConvertConstBase : public ::mlir::FunctionPass {
public:
  QuantConvertConstBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  QuantConvertConstBase(const QuantConvertConstBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "quant-convert-const"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "QuantConvertConst"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
};

//===----------------------------------------------------------------------===//
// QuantConvertSimulatedQuant
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class QuantConvertSimulatedQuantBase : public ::mlir::FunctionPass {
public:
  QuantConvertSimulatedQuantBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  QuantConvertSimulatedQuantBase(const QuantConvertSimulatedQuantBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "quant-convert-simulated-quantization"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "QuantConvertSimulatedQuant"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
#ifdef GEN_PASS_REGISTRATION
#define GEN_PASS_REGISTRATION_QuantConvertConst
#define GEN_PASS_REGISTRATION_QuantConvertSimulatedQuant
#endif // GEN_PASS_REGISTRATION
#ifdef GEN_PASS_REGISTRATION_QuantConvertConst
::mlir::registerPass("quant-convert-const", "Converts constants followed by qbarrier to actual quantized values", []() -> std::unique_ptr<::mlir::Pass> { return mlir::quant::createConvertConstPass(); });
#endif // GEN_PASS_REGISTRATION_QuantConvertConst
#undef GEN_PASS_REGISTRATION_QuantConvertConst
#ifdef GEN_PASS_REGISTRATION_QuantConvertSimulatedQuant
::mlir::registerPass("quant-convert-simulated-quantization", "Converts training-time simulated quantization ops to corresponding quantize/dequantize casts", []() -> std::unique_ptr<::mlir::Pass> { return mlir::quant::createConvertSimulatedQuantPass(); });
#endif // GEN_PASS_REGISTRATION_QuantConvertSimulatedQuant
#undef GEN_PASS_REGISTRATION_QuantConvertSimulatedQuant
#ifdef GEN_PASS_REGISTRATION
#undef GEN_PASS_REGISTRATION_QuantConvertConst
#undef GEN_PASS_REGISTRATION_QuantConvertSimulatedQuant
#endif // GEN_PASS_REGISTRATION
#undef GEN_PASS_REGISTRATION
